# Logger - Система логирования

Централизованная система логирования для всех компонентов RAG-системы. Обеспечивает единообразный формат записи событий, ошибок и отладочной информации во всём проекте.

## Назначение

Модуль `logger.py` предоставляет инструменты для записи информации о работе программы (логирование). Вместо использования обычных `print()`, которые выводят текст только на экран, этот модуль позволяет:

- Записывать события одновременно на экран и в файл
- Автоматически добавлять к каждому сообщению время, уровень важности и место в коде
- Настраивать детальность логирования (показывать только ошибки или всю информацию)
- Обеспечивать единый стиль логов во всех частях системы

## Где используется

Модуль логирования используется **во всех компонентах RAG-системы**:

- **Скрипты обработки данных** - записывают процесс загрузки, обработки и сохранения документов
- **API обёртки** - фиксируют запросы к внешним сервисам и полученные ответы
- **Утилиты** - логируют вспомогательные операции (работа с файлами, валидация и т.д.)
- **Основные модули** - отслеживают критические операции и ошибки

Логирование помогает понять, что происходит в программе, найти причины ошибок и отследить процесс выполнения задач.

## Основные возможности

- **Единая настройка** - логирование настраивается один раз при запуске приложения
- **Двойной вывод** - сообщения автоматически пишутся и на экран, и в файл (если указан)
- **Структурированный формат** - каждое сообщение содержит время, источник, уровень важности и текст
- **Автоматическая ротация** - при возобновлении работы можно легко переключиться на новый лог-файл
- **Безопасное закрытие** - гарантирует, что все сообщения записаны перед завершением программы

## Публичные настройки

### Константы

**DEFAULT_FORMAT** - формат сообщений по умолчанию
```
"%(asctime)s | %(name)s | %(levelname)s | %(filename)s:%(lineno)d | %(message)s"
```
Расшифровка частей:
- `asctime` - дата и время события
- `name` - имя модуля (обычно путь к файлу)
- `levelname` - уровень важности (INFO, WARNING, ERROR и т.д.)
- `filename:lineno` - имя файла и номер строки, откуда пришло сообщение
- `message` - текст сообщения

**DEFAULT_LEVEL** - уровень логирования по умолчанию (`logging.INFO`)

Уровни важности (от самого детального к критическому):
- `DEBUG` - детальная отладочная информация
- `INFO` - общая информация о работе программы (по умолчанию)
- `WARNING` - предупреждения о потенциальных проблемах
- `ERROR` - ошибки, не прерывающие работу
- `CRITICAL` - критические ошибки, требующие немедленного внимания

### Параметры функции setup_logging()

**log_file** (необязательный)
- Путь к файлу для записи логов
- Если не указан - логи выводятся только на экран
- Пример: `Path("logs/app.log")`
- Директория создаётся автоматически, если не существует

**level** (необязательный, по умолчанию `logging.INFO`)
- Минимальный уровень важности сообщений для записи
- Сообщения с уровнем ниже указанного игнорируются
- Примеры: `logging.DEBUG`, `logging.INFO`, `logging.ERROR`

**format_string** (необязательный)
- Пользовательский формат сообщений
- Если не указан - используется DEFAULT_FORMAT
- Позволяет настроить, какую информацию включать в каждое сообщение

**force_reconfigure** (необязательный, по умолчанию `False`)
- Принудительная полная переконфигурация логирования
- Обычно не требуется, так как модуль автоматически обновляет только файл логов при повторных вызовах

## Примеры использования

### Базовая настройка (вывод только на экран)

```python
from utils.logger import setup_logging, get_logger

# Настройка логирования один раз при старте программы
setup_logging()

# Получение логгера для текущего модуля
logger = get_logger(__name__)

# Использование
logger.info("Программа запущена")
logger.warning("Низкий объем свободной памяти")
logger.error("Не удалось подключиться к базе данных")
```

### Настройка с записью в файл

```python
from pathlib import Path
from utils.logger import setup_logging, get_logger

# Логи будут записываться и на экран, и в файл
setup_logging(log_file=Path("logs/application.log"))

logger = get_logger(__name__)
logger.info("Логирование в файл активировано")
```

### Настройка с детальным уровнем отладки

```python
import logging
from pathlib import Path
from utils.logger import setup_logging, get_logger

# Включаем максимально детальное логирование
setup_logging(
    log_file=Path("logs/debug.log"),
    level=logging.DEBUG
)

logger = get_logger(__name__)
logger.debug("Детальная отладочная информация")
logger.info("Обычная информация")
```

### Использование в разных модулях

```python
# В модуле data_processor.py
from utils.logger import get_logger

logger = get_logger(__name__)  # Получит имя 'data_processor'

def process_documents():
    logger.info("Начало обработки документов")
    try:
        # ... обработка ...
        logger.info("Обработано 150 документов")
    except Exception as e:
        logger.error(f"Ошибка обработки: {e}")
```

### Корректное завершение работы

```python
from utils.logger import setup_logging, get_logger, close_logging

setup_logging(log_file=Path("logs/app.log"))
logger = get_logger(__name__)

try:
    logger.info("Выполнение задачи")
    # ... основной код ...
finally:
    # Гарантирует запись всех логов перед выходом
    close_logging()
```

---

**Примечание**: Этот модуль автоматически инициализируется при импорте, поэтому даже без явного вызова `setup_logging()` базовое логирование на экран будет работать.