
**Входные данные**:
- INPUT_FILE_Q_A = Path("in/Q_A.xlsx") - это копия файла INPUT_FILE_Q = Path("in/Q.xlsx"), где на листе SHEET_Q = "Q" даны ответы на вопросы в колонке COL_Q_ANSWER = 2;

- INPUT_FILE_QA = Path("in/QA.xlsx") - это категоризированные и загруженные в векторную БД исторические вопросы и ответы;

**Выходные данные**:
- Q_A_YYYY-MM-DD_HHMMSS.xlsx - это копия входного файла INPUT_FILE_Q_A, где на лист SHEET_Q = "Q", начиная с первой свободной колонки добавлены:
	- original_question из INPUT_FILE_QA, SHEET_QA = "QA", COL_QA_QUESTION = 2
	- original_answer из INPUT_FILE_QA, SHEET_QA = "QA", COL_QA_ANSWER = 3


 INPUT_FILE_Q, где на листе SHEET_Q даны ответы на вопросы в колонке COL_Q_ANSWER;


---
Выступай в роли эксперта по разработке инструментов для обработки данных, включая их отдельные компоненты: обёртки для API и библиотек, а также вспомогательные скрипты.

**Формат взаимодействия**
Ты — *professional solo developer*, который наставляет *beginner solo developer* в создании компонента на Python 3.12+.

**Принципы разработки**:
* **KISS (Keep It Simple, Stupid)** — решения просты, надёжны, легко поддерживаются, без лишней сложности.
* **YAGNI (You Aren't Gonna Need It)** — никакой преждевременной оптимизации.
* **DRY (Don’t Repeat Yourself)** — избегать дублирования кода и данных; всё должно иметь единственный источник правды.
* **Fail Fast** — ошибки должны проявляться как можно раньше, а не прятаться.
* Только **Stdlib-only**, если это не ведет к усложнению кода. 
* Типизация и совместимость с *pylint* и *mypy*.
* Отсутствие требований обратной совместимости.

---
Дано: 
- новый скрипт ответа на вопросы на базе LLM;
- вопросы и эталонные ответы;
- новые ответы на вопросы с помощью нового скрипта;

Необходимо максимально просто, но профессионально реализовать оценку, насколько новый ответ близок к эталонному с помощью метода LLM-as-Judge.
Для реализации оценки используй «СИММЕТРИЧНЫЙ ENTAILMENT»
Код не пиши.
Ответь в виде описания методологии и структур данных для реализации оценки.



# «СИММЕТРИЧНЫЙ ENTAILMENT»


## 1) Критерии и формулы

* **Entailment R→C (coverage/recall):** насколько новый ответ покрывает смысл эталона (0–1).
* **Entailment C→R (precision):** не добавляет ли новый ответ лишнего относительно эталона (0–1).
* **Semantic F1 = 2·(P·R)/(P+R)**, где *P = C→R*, *R = R→C*.
* **Штрафы:**

  * **contradiction\_flag** (обнаружено логическое противоречие эталону) → −0.20
  * **hallucination\_flag** (существенные факты, не вытекающие из вопроса/эталона) → −0.10
  * Итог: **score = max(0, F1 − penalties)**, масштабируем до 0–100.
* **Численные ответы:** разрешить допустимое отклонение (по умолчанию относительное ±2% или абсолютное окно, если указано). Судья явно сверяет числа/единицы.

## 2) Инструкция судье (суть)

* Контекст: вопрос, эталон, новый ответ.
* Определи две оценки *R→C* и *C→R* в \[0, 1] (три градации достаточно: 0.0, 0.5, 1.0; при желании — 0.0–1.0 с шагом 0.1).
* Отметь **contradiction\_flag** (да/нет) и **hallucination\_flag** (да/нет) — «галлюцинации» трактуем как существенные утверждения, не следующие из вопроса или эталона.
* Верни **краткую** мотивацию (≤ 40 слов) **без пошаговых рассуждений** и укажи **цитаты-доказательства**: 1–2 коротких фрагмента из нового ответа и/или эталона, на которые ты опираешься.
* Строгая детерминированность: `temperature=0`, `top_p=1`.
* Вывод в фиксированном JSON-схемном формате (ключи: `precision_c_to_r`, `recall_r_to_c`, `contradiction`, `hallucination`, `justification`, `evidence`).

## 3) Пороговые зоны для регресса

* **≥ 85:** эквивалентно эталону или лучше по деталям (без галлюцинаций).
* **70–84:** близко, но есть неполнота/лишние детали или мелкие расхождения.
* **< 70:** заметные потери смысла, противоречия или галлюцинации — требует правки.
