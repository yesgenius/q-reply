# Руководство пользователя

## Автоматическая категоризация вопросов по Excel с использованием LLM (GigaChat)

Это руководство поможет вам:
* понять, **как устроены два модуля** (`category_filler.py` и `define_category_prompt.py`);
* **подготовить Excel**, запустить скрипт и получить результат;
* **настроить поведение**: где менять параметры, как включить/выключить опции, как безопасно продолжать после ошибок;
* аккуратно **подправить LLM-параметры** и системный промпт без лишней сложности.

---

## Инструменты

* **category\_filler.py** — надёжный «оркестратор»: проверяет Excel, копирует, валидирует, безопасно вызывает LLM, пишет результаты и умеет продолжать после сбоев;
* **define\_category\_prompt.py** — строгий «контракт» с моделью: формирует понятный системный промпт, требует **только валидный JSON**, валидирует каждое поле, не допускает «левых» категорий;


---

## 1) Короткий обзор логики

1. **Входной Excel**: по умолчанию `in/QA.xlsx`. Ожидаются два листа — `QA` и `CATEGORY`;
2. **Справочник категорий** берётся из листа `CATEGORY`:
   * A — имя категории, 
   * B — её описание (обе колонки должны быть заполнены);
3. **Данные для классификации** на листе `QA`:
   * A — целевая колонка «Категория» (скрипт будет сюда писать),
   * B — «Вопрос»,
   * C — «Ответ» (обязателен для заполнения, даже если вы планируете не использовать его в классификации);
4. Скрипт копирует исходный `QA.xlsx` в `out/QA_<дата_время>.xlsx`, создаёт (если включено) лог-лист `LOG_CATEGORY` и **строка за строкой** вызывает LLM, записывая результат в колонку A листа `QA` и подробный лог;
5. Вызов LLM строится из:
   * **system** - формирует строгие правила вывода: **только JSON** с полями `category`, `confidence`, `reasoning`,
   * **user** - сообщения с вопросом + при включенной опции — с ответом как контекстом;
6. Ответ LLM **парсится и валидируется**: если категория вне списка, неверный формат JSON или нет чисел — будет ошибка;
7. Есть **безопасные сохранения** по ходу (каждые N строк) + **resume**-файл для продолжения с места сбоя;

---

## 2) Подготовка окружения и проекта

### Требования

* Python 3.9+
* Пакеты:
  ```bash
  pip install openpyxl
  ```

* `define_category_prompt.py` импортирует модуль как `from gigachat.client import GigaChatClient`. Убедитесь, что библиотека и **учётные данные** для GigaChat настроены верно;
* `category_filler.py` импортирует модуль как `from prompts import define_category_prompt`, поэтому **файл должен лежать в папке `prompts/`** рядом с основным скриптом;


### Тестирование модулей
* Команды должны выполняться без ошибок:
  ```bash
  python -m gigachat.client
  python -m prompts.define_category_prompt
  ```

### Структура папок

```
q-reply/
├─ in/
│  └─ QA.xlsx                     # исходные данные
├─ out/                           # сюда пишется результат
│
├─ prompts/
│  └─ define_category_prompt.py
│
├── gigachat/                     # ОБЕРТКА REST API LLM
│   ├── __init__.py
│   ├── config.py                 # Загрузка .env
│   └── client.py                 # класс GigaChatConfig с методами для получения: ответов, эмбеддингов, списка моделей
│
├── category_filler.py            # Заполнение категорий исторических вопросов
│
├── .env                          # Секретные переменные
└── certs/                        # TLS СЕРТИФИКАТЫ
```

---

## 3) Формат Excel

### Лист `CATEGORY` (обязательно)

* **A (Category)** — имя категории (строка, уникальна).
* **B (Description)** — краткое описание.
* Данные начинаются со **второй** строки (первая — заголовки). Пустые строки пропускаются; если A или B пусты — скрипт остановится с ошибкой;

### Лист `QA` (обязательно)

* **A (Category)** — поле для записи результата. Можно оставить пустым, если категоризации ещё не было.
* **B (Question)** — вопрос (обязателен).
* **C (Answer)** — ответ (обязателен как минимум с непустым значением; если нет ответа — поставьте `-`). Скрипт строго проверяет, чтобы в B и C были данные;

---

## 4) Быстрый старт

1. Подготовьте `in/QA.xlsx` с двумя листами (`QA` и `CATEGORY`) в описанном формате;
2. Убедитесь, что:
   * учётные данные GigaChat настроены для `GigaChatClient`;
3. Запустите:
   ```bash
   python category_filler.py
   ```
4. Результат появится в папке `out/` как `QA_YYYY-MM-DD_HHMMSS.xlsx`. При включённом логировании будет лист `LOG_CATEGORY`;

---

## 5) Настройки и где их менять

Константы расположены в начале `category_filler.py` - раздел **CONFIGURATION SECTION**.
Меняйте **только при необходимости**.

### Пути и листы

* `INPUT_FILE = Path("in/QA.xlsx")` — путь к исходному Excel; можно заменить на свой;
* `OUTPUT_DIR = Path("out")` — куда сохранять результат;
* `SHEET_QA = "QA"`, `SHEET_CATEGORY = "CATEGORY"` — имена листов;

---

### **Колонки (нумерация 1-based для openpyxl)**

> В `openpyxl` колонки считаются с **1** (A=1, B=2, C=3). Эти переменные говорят скрипту, в какие колонки листа Excel смотреть или писать данные.

* **`COL_QA_CATEGORY = 1`**

  * Это колонка A на листе `QA`.
  * В неё скрипт записывает **результат категоризации** (`category` из ответа модели).
  * Если там уже есть корректная категория(и) из справочника — строка не пойдёт в модель.

* **`COL_QA_QUESTION = 2`**

  * Колонка B на листе `QA`.
  * Здесь хранится **вопрос**, который вы классифицируете.
  * Это поле скрипт читает всегда и передаёт в модель как основную часть запроса.

* **`COL_QA_ANSWER = 3`**

  * Колонка C на листе `QA`.
  * Здесь — **ответ** на вопрос (может быть «-», если нет настоящего ответа).
  * Если `USE_ANSWER_FOR_CATEGORIZATION = True`, этот текст пойдёт в модель в дополнение к вопросу, что повышает точность.

* **`COL_CATEGORY_NAME = 1`**

  * Колонка A на листе `CATEGORY`.
  * Здесь имя категории (строка). Должно быть уникальным.
  * Скрипт собирает этот список и использует для проверки валидности.

* **`COL_CATEGORY_DESC = 2`**

  * Колонка B на листе `CATEGORY`.
  * Краткое **описание** категории.
  * Модель получает этот список категорий вместе с описаниями, чтобы понимать, что значит каждая категория.

---

### **Как использовать «Ответ» при категоризации**

* **`USE_ANSWER_FOR_CATEGORIZATION = True`**

  * Если `True` → в промпт к LLM передаётся **и вопрос (из колонки B)**, и ответ (из колонки C).
  * Если `False` → в модель отправляется **только вопрос**.
  * Важно: даже если не используете ответ в запросе (`False`), колонка C **не должна быть пустой** — валидация данных требует, чтобы и вопрос, и ответ были заполнены.

---

### **Логирование и лист логов**

* **`LOG_CATEGORY = True`**

  * Если `True` → создаётся отдельный лист `LOG_CATEGORY` в итоговом Excel.
  * Туда пишутся:

    1. Категория, что было в колонке QA.A
    2. Вопрос, что было в колонке QA.B
    3. Предсказанная категория (`category`)
    4. Уверенность (`confidence`)
    5. Пояснение (`reasoning`)
    6. Полный запрос к LLM (`messages`) — system, history, user.
  * Если `False` → лист `LOG_CATEGORY` не создаётся, лог будет только в консоли.

* **`LOG_LEVEL = logging.INFO`**

  * Определяет, сколько сообщений скрипт выводит в консоль:

    * `logging.INFO` → обычные сообщения + прогресс;
    * `logging.DEBUG` → ещё больше деталей (для отладки);
    * `logging.ERROR` → только ошибки.

---

### **Производительность и надёжность**

* **`START_ROW = 2`**

  * Номер строки в Excel, с которой начинать обработку (1-я строка — заголовки).
  * Если ваши данные начинаются позже — поменяйте это значение.

* **`SAVE_FREQUENCY = 5`**

  * Сохраняются на диск каждые 5 обработанных строк.

* **`RESUME_FILE = Path(".category_filler_resume.json")`**

  * Служебный JSON-файл для механизма «продолжить после сбоя».
  * Скрипт записывает туда номер последней успешно обработанной строки.
  * При следующем запуске, если файл есть, скрипт продолжит с этого места.
  * Файл удаляется при успешном завершении обработки.


---

## 6) Что именно делает `define_category_prompt.py` и как это настраивать

### Роль модуля

* Держит **кешированный системный промпт** (и при желании историю чата).
* Формирует **строгий** промпт со списком доступных категорий и правилами вывода **только валидного JSON**.
* Вызывает `GigaChatClient.chat_completion(messages=..., **params)`.
* **Парсит ответ**, вырезая JSON даже если LLM «наболтал» что-то вокруг, и жёстко валидирует: поля, типы, границы, принадлежность `category` к разрешённому списку;

### Параметры модели (при необходимости можно менять)

Словарь `params` в начале файла:

```python
params = {
  "model": "GigaChat",
  "temperature": 0.1,
  "top_p": 0.95,
  "stream": False,
  "max_tokens": 300,
  "repetition_penalty": 1.0,
}
```

Рекомендации:

* **Не включайте** `stream=True`: модуль специально запрещает стриминг для структурированного JSON;
* `temperature=0.1` — держите низкой для стабильной категоризации;
* `max_tokens=300` достаточно для JSON + короткого «reasoning». Если «обрезает» — увеличьте до 500.

---

## 7) Что получите на выходе

* Файл `out/QA_YYYY-MM-DD_HHMMSS.xlsx` — копия исходного Excel, дополненная результатами:

  * На листе `QA` в колонке A — обновлённая категория.
  * (Если `LOG_CATEGORY=True`) лист `LOG_CATEGORY` с колонками:

    1. исходная «Категории» (что было),
    2. «Вопросы»,
    3. `category` (что предсказал LLM),
    4. `confidence`,
    5. `reasoning`,
    6. `messages` — весь отправленный запрос (system/history/user) в читабельном виде с переносами строк;

---

## 8) Алгоритм определения категорий

1. Проверка доступности файла и наличия листов `QA`/`CATEGORY`;
2. Создание копии файла в `out/` с таймстампом, подготовка листа `LOG_CATEGORY` (если включён);
3. Загрузка словаря категорий (оба столбца обязательны);
4. Инициализация системы категоризации: системный промпт со списком категорий + кеш;
5. Валидация данных `QA`: у каждой строки должны быть и вопрос, и ответ; категории, если уже стоят, проверяются (включая мультистрочные). Скрипт формирует список «строк к обработке»;
6. Проход по строкам:

   * сбор сообщений (system + \[history] + user с вопросом и опционально ответом),
   * вызов LLM, парсинг и валидация JSON,
   * запись категории в `QA`, подробностей — в `LOG_CATEGORY`,
   * периодические сохранения + запись «resume» состояния;
7. Финальное сохранение, очистка `resume` при успешном завершении;
